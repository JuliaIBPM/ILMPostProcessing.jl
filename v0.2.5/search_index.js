var documenterSearchIndex = {"docs":
[{"location":"manual/functions/#Functions-and-types","page":"Functions and types","title":"Functions and types","text":"","category":"section"},{"location":"manual/functions/#Functions","page":"Functions and types","title":"Functions","text":"","category":"section"},{"location":"manual/functions/#ILMPostProcessing.adams_bashforth_2_backward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.adams_bashforth_2_backward","text":"adams_bashforth_2_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate backward in time to compute backward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.adams_bashforth_2_forward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.adams_bashforth_2_forward","text":"adams_bashforth_2_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_FTLE!-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE, nx, ny, T, final_positions, dx, dy)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: an empty 2D array (i.e., FTLE = zeros(Float64, ny - 2, nx - 2)), nx - 2 and ny - 2 accounts for the boundary points in the central difference formula\nnx: number of grid points in x \nny: number of grid points in y \nT: length of integration time\nfinal_positions: solutions of the IVP \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_FTLE!-Tuple{Any, Any, Any, Real, Real, Real}","page":"Functions and types","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE::ScalarGridData, final_x::ScalarGridData, final_y::ScalarGridData, dx::Real, dy::Real, T::Real)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: will hold the FTLE field, in ScalarGridData type\nfinal_x: deformed x positions, in ScalarGridData type\nfinal_y: deformed y positions, in ScalarGridData type \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_IVD!-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.compute_IVD!","text":"compute_IVD!(IVD, traj, X_MIN, Y_MIN, X_MAX, Y_MAX, vortseq)\n\nCompute the instantaneous vorticity deviation IVD field given the trajectories traj and the vorticity field sequence vortseq. \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_LAVD!-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.compute_LAVD!","text":"compute_LAVD!(LAVD, traj, X_MIN, Y_MIN, X_MAX, Y_MAX, vortseq)\n\nCompute the Lagrangian-averaged vorticity deviation LAVD field given the trajectories traj and the vorticity field sequence vortseq. \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_streakline-Union{Tuple{S}, Tuple{Union{Tuple, Vector}, Vector{S}, Real}} where S<:Real","page":"Functions and types","title":"ILMPostProcessing.compute_streakline","text":"compute_streakline(u,v,X₀::Vector,t[;τmin = t-3.0, dtstreak=0.01,dttraj=0.001]) -> Vector, Vector\n\nCalculate a streakline at time t for a velocity field u and v, based on an injection point X₀. The end of the streakline is set by τmin, the earliest time at which a particle passed through the injection point. It defaults to 3 time units before the current instant t. The time step size dtstreak sets the resolution of the streakline (i.e., how often the particles are sampled along the streakline). It returns arrays of the x and y coordinates of the streakline.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_streamline-Tuple{Function, Function, Any, Tuple, Real}","page":"Functions and types","title":"ILMPostProcessing.compute_streamline","text":"compute_streamline(u,v,X₀,srange::Tuple,t::Real,[;dt=0.01])\n\nCalculate the streamline(s) passing through location(s) X₀, which can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for a rake of streamlines. The arguments u and v are either interpolated velocity field components from a computational solution or are functions. If they are functions, then each of them should be of the form u(x,y,t) and v(x,y,t); srange is a tuple of the initial and final time of integration; t is the current time at which the streamline is depicted; and Δs is the time-like step size, which defaults to 0.001. The output is the solution structure for the OrdinaryDiffEq package (or, for multiple points, a vector of such solution structures).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_trajectory-Tuple{VectorFieldSequence, Any, Tuple}","page":"Functions and types","title":"ILMPostProcessing.compute_trajectory","text":"compute_trajectory(v::VectorFieldSequence,X₀,Trange::Tuple[;dt=step(tr),alg=Euler()])\n\nCalculate the trajectories of particles with initial location(s) X₀. The argument v contains a sequence of spatially-interpolated velocity fields and an associated time array. (One can also provide the vector of velocity fields and the time array as separate arguments).\n\nX₀ can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for multiple tracer particles. Trange is a tuple of the starting and ending integration times. The optional keyword arguments are dt, the time step size (which defaults to the step size in tr, but could be an integer multiple larger than 1). The output is the solution structure for the OrdinaryDiffEq package.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_trajectory-Union{Tuple{T}, Tuple{T, T, Any, Tuple}} where T<:Interpolations.AbstractInterpolation","page":"Functions and types","title":"ILMPostProcessing.compute_trajectory","text":"compute_trajectory(u,v,X₀,Trange::Tuple[;dt=0.01])\n\nCalculate the trajectory of a tracer particle with initial location(s) X₀, which can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for multiple tracer particles. The arguments u and v are either interpolated velocity field components from a computational solution or are functions. If they are functions, then each of them should be of the form u(x,y,t) and v(x,y,t); Trange is a tuple of the initial and final time of integration (and the final time can be earlier than the initial time if backward trajectories are desired); and dt is the time step size, which defaults to 0.01. The output is the solution structure for the OrdinaryDiffEq package (or, for multiple particles, a vector of such solution structures).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.ddt-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T, S}","page":"Functions and types","title":"ILMPostProcessing.ddt","text":"ddt(u::AbstractVector,Δt[,mydiff=:backward_diff])\n\nCalculate the time derivative of vector data u, with time step size Δt. The default method is backward differencing, but this can be changed to :forward_diff or :central_diff.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.displacement_field-Tuple{Function, Function, Any, Any, Tuple}","page":"Functions and types","title":"ILMPostProcessing.displacement_field","text":"displacement_field(u::Function,v::Function,x0,y0,Trange::Tuple[;dt=:auto,alg=Euler()])\n\nCalculate the displacement of particles initally at coordinates x0 and y0 over the range of times Trange = (ti,tf), using the  velocity functions u and v.  These function can either be autonomous (taking only x and y arguments) or non-autonomous, taking an additional time argument. The final time in Trange can be earlier than the initial time if backward trajectories are desired. The optional keyword arguments are dt, the time step size (which defaults to :auto, for adaptive time marching, but could be specified to override this). The default time marching algorithm is Tsit5(). \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.displacement_field-Tuple{VectorFieldSequence, Any, Any, Tuple}","page":"Functions and types","title":"ILMPostProcessing.displacement_field","text":"displacement_field(v::VectorFieldSequence,x0,y0,Trange::Tuple[;dt=step(tr),alg=Euler()])\n\nCalculate the displacement of particles initally at coordinates x0 and y0 over the range of times Trange = (ti,tf), using the sequence of spatially-interpolated velocity fields in v. (One can also provide the vector of velocity fields and the time array as separate arguments). The final time in Trange can be earlier than the initial time if backward trajectories are desired. The optional keyword arguments are dt, the time step size (which defaults to the step size in tr, but could be an integer multiple larger than 1). \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.dmd-Union{Tuple{T}, Tuple{Vector{T}, Integer}} where T","page":"Functions and types","title":"ILMPostProcessing.dmd","text":"dmd(Xfull,r)\n\nCompute the first r DMD modes from the extended snapshot data in Xfull. Both the original and shifted data are drawn from Xfull, that is: X = Xfull[1:m-1] and Xp = Xfull[2:m]\n\nThis returns the DMD modes and DMD eigenvalues in a DMDModes structure, with fields modes and evals.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.euler_backward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.euler_backward","text":"euler_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate backward in time to compute backward FTLE fields. Note: not backward Euler method.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.euler_forward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.euler_forward","text":"euler_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.field_along_trajectory-Tuple{Any, Any, Any}","page":"Functions and types","title":"ILMPostProcessing.field_along_trajectory","text":"fieldalongtrajectory(f,traj::Trajectories,p::Integer[,deriv=0])\n\nEvaluate field f (given as grid data) along the trajectory number p in the  trajectories specified by traj. The output is the history of f along this trajectory. If f is a vector field, then the component histories are output as a tuple. If deriv=1, then it computes the time derivative of the field along the trajectory. The default is deriv=0 (no derivative).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.gen_init_conds-NTuple{6, Any}","page":"Functions and types","title":"ILMPostProcessing.gen_init_conds","text":"gen_init_conds(X_MIN, X_MAX, Y_MIN, Y_MAX, nx, ny)\n\nGenerate a list of initial points (x, y).\n\nThese initial conditions represent a collocated grid with nx points in (X_MIN, X_MAX) and ny points in (Y_MIN, Y_MAX). The points are then flattened to a 1D array. The initial conditions could be used to compute FTLE or to visaulize trajectories.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.make_interp_fields!-NTuple{9, Any}","page":"Functions and types","title":"ILMPostProcessing.make_interp_fields!","text":"make_interp_fields!(u, v, t_start, t_end, dt, velocity_fn, sol, sys, grid)\n\nGenerate an array of interpolatable velocity fields u and v using the solution of a ViscousFlow problem. \n\nEach element of u and v is essentially a \"Vectorfield!\" used when solving an ODEProblem. Note: This function could be included in ViscousFlow.jl. \n\nArguments\n\nu: x-velocity fields\nv: y-velocity fields\nt_start: start time of sol\nt_end: end time of sol \ndt: step size between consecutive velocity fields\nvelocity_fn: function to compute velocity from solution, should be ViscousFlow.velocity\nsys: viscous flow system\ngrid: physical grid\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.pod-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Functions and types","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T}[; tolerance=0.99])\n\nCalculate the POD modes and associated time-varying coefficients from an array of snapshot data X. This X plays the role of a snapshot matrix, whose columns are snapshots of the data. However, it is actually to be stored as a type Vector{T} where T<:GridData. It can be generated with a function like velocity(sol,sys,trange), where sol is a ODESolution, sys is an ILMSystem, and trange is an array of times, e.g., trange=range(1,10,length=100). The number of POD modes retained in the decomposition is set by tolerance: this specifies the fraction of the total energy to keep, and defaults to 99 percent. \n\nThe output of PODModes is a structure with the following fields\n\nXmean: temporal mean of the data. type T\nXnorm: original X vector with mean removed. Each element is of type T\nphi: vector of POD modes. Each element is of type T\na: matrix of POD coefficients. Number of columns is same as number of entries in phi. Column k constitutes the time-varying coefficient for mode k in phi.\nlambda: vector of modal energies, arranged in decreasing order, corresponding to the modes in phi\npsi: matrix of \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.pod-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T","page":"Functions and types","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T},r::Int)\n\nPerform POD on snapshot data X and truncate to r modes\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#Types","page":"Functions and types","title":"Types","text":"","category":"section"},{"location":"manual/functions/#ILMPostProcessing.ScalarFieldSequence","page":"Functions and types","title":"ILMPostProcessing.ScalarFieldSequence","text":"ScalarFieldSequence(t::AbstractVector,s)\n\nThis type bundles a time vector t with a vector s of interpolatable scalar fields (i.e., each element is of type AbstractInterpolation with two spatial coordinate arguments). It is used for plotting fields along trajectories. \n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#ILMPostProcessing.Trajectories","page":"Functions and types","title":"ILMPostProcessing.Trajectories","text":"Trajectories\n\nType returned by trajectory calculations, containing a set of one or more trajectories. For an instance traj of this type, the trajectory time array can be returned with traj.t. The number of trajectories is returned by traj.np. Any trajectory contained in the set can be obtained with traj[p], where p must be 0 < p <= traj.np. \n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#ILMPostProcessing.VectorFieldSequence","page":"Functions and types","title":"ILMPostProcessing.VectorFieldSequence","text":"VectorFieldSequence(t::AbstractVector,v)\n\nThis type bundles a time vector t with a vector v of tuples of interpolatable fields (i.e., each member of the tuple is of type AbstractInterpolation with two spatial coordinate arguments). It is used in trajectory computations and for plotting fields along trajectories. \n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#Index","page":"Functions and types","title":"Index","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"manual/lavd/#Lagrangian-averaged-vorticity-deviation-(LAVD)","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"In this example, we will compute the Lagrangian-averaged vorticity deviation (LAVD) field for a flat plate undergoing a 45-degree pitch-up maneuver. The original simluation of the flat plate was used by Wang and Eldredge 2012 (https://doi.org/10.1007/s00162-012-0279-5). The results are compared with Huang and Green 2016 (https://arc.aiaa.org/doi/10.2514/6.2016-2082). The theory behind LAVD can be found in Haller et al. 2016 (https://doi.org/10.1017/jfm.2016.151). A MATLAB package for computing LAVD and extracting coherent vortices can be found here (https://github.com/Hadjighasem/Lagrangian-Averaged-Vorticity-Deviation-LAVD).","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"using ILMPostProcessing\nusing ViscousFlow\nusing Plots\nusing Statistics","category":"page"},{"location":"manual/lavd/#Viscous-Flow-of-Pitching-Flat-Plate","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Viscous Flow of Pitching Flat Plate","text":"","category":"section"},{"location":"manual/lavd/#Problem-Specification","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Problem Specification","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"For faster compututation and testing purposes, the Reynolds number is set to 100 as opposed to 1000 in Huang's paper. The grid Re is also set to 4.0. If better resolution is desired, try grid Re = 3.0. The domain of interest is from x = -0.5 to x = 5.5, but it is set from x = -3.0 to x = 5.5 since the velocity and vorticity fields ahead of the flat plate are required to compute LAVD.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"my_params = Dict()\nmy_params[\"Re\"] = 100\nmy_params[\"grid Re\"] = 4.0\nmy_params[\"freestream speed\"] = 1.0\nmy_params[\"freestream angle\"] = 0.0\n\nxlim = (-3.0,5.5)\nylim = (-2.0,1.0)\ng = setup_grid(xlim,ylim,my_params)\nΔs = surface_point_spacing(g,my_params)","category":"page"},{"location":"manual/lavd/#Set-up-Body","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Set up Body","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Create a rectangle of length 1.0 and thickness 0.023.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Lp = 1.0\nbody = Rectangle(Lp/2,0.023/2,Δs)\nbl = BodyList([body])","category":"page"},{"location":"manual/lavd/#Set-the-Body-Motion","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Set the Body Motion","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Create a smooth position ramp of 45 degreess of the flat plate's angle of attack about its leading edge.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"vel = 45pi/180  ## nominal ramp velocity\nΔx = -45pi/180 ## change in position\nt0 = 1.0 ## time of ramp start\nk = SmoothRampDOF(vel,Δx,t0)","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Plot the ramp.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"t = range(0,3,length=301)\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Create the joint.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"parent_body, child_body = 0, 1\nXp = MotionTransform([0,0],0) # location of joint in inertial system\nxpiv = [-0.5,0] # place center of motion at LE\nXc = MotionTransform(xpiv,0)\njoint1 = Joint(RevoluteJoint,parent_body,Xp,child_body,Xc,[k])\nm = RigidBodyMotion([joint1],bl)\n\nx = init_motion_state(bl,m)\nupdate_body!(bl,x,m)\nplot(bl,xlim=xlim,ylim=ylim)","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Animate the motion","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"macro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, init_motion_state(bc,$m)\n            dxdt = zero(x0)\n            x = copy(x0)\n\n            @gif for t in t0:$dt:t0+$tmax\n                motion_rhs!(dxdt,x,($m,bc),t)\n                global x += dxdt*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlim=$xlim,ylim=$ylim)\n            end every 5\n        end)\nend\n\n@animate_motion bl m 0.01 4 (-0.5, 5.5) ylim","category":"page"},{"location":"manual/lavd/#Define-the-Boundary-Condition-Functions","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Define the Boundary Condition Functions","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"function my_vsplus(t,x,base_cache,phys_params,motions)\n  vsplus = zeros_surface(base_cache)\n  surface_velocity!(vsplus,x,base_cache,motions,t)\n  return vsplus\nend\n\nfunction my_vsminus(t,x,base_cache,phys_params,motions)\n  vsminus = zeros_surface(base_cache)\n  surface_velocity!(vsminus,x,base_cache,motions,t)\n  return vsminus\nend\n\nbcdict = Dict(\"exterior\" => my_vsplus, \"interior\" => my_vsminus)","category":"page"},{"location":"manual/lavd/#Construct-the-system-structure","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Construct the system structure","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"sys = viscousflow_system(g,bl,phys_params=my_params,motions=m,bc=bcdict);\nu0 = init_sol(sys)","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Check the effective Reynolds number.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Umax, imax, tmax, bmax = maxvelocity(u0,sys)\nL = Lp\nRe_eff = my_params[\"Re\"]*Umax*L","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Initialize the solver.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"tspan = (0.0,10.0)\nintegrator = init(u0,tspan,sys,alg=LiskaIFHERK(saddlesolver=CG))\n\nstep!(integrator)\n@time step!(integrator,9.0)","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Plot the solutions.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"sol = integrator.sol\nplt = plot(layout = (5,2), size = (1000, 1200), legend=:false)\ntsnap = 0.0:1.0:9.0\nfor (i, t) in enumerate(tsnap)\n    plot!(plt[i],vorticity(sol,sys,t),sys,layers=false,title=\"t = $(round(t,digits=2))\",clim=(-5,5),levels=range(-5,5,length=30),color = :RdBu, xlim = (-0.5, 5.5))\n    plot!(plt[i],surfaces(sol,sys,t))\nend\nplt","category":"page"},{"location":"manual/lavd/#Compute-LAVD","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Compute LAVD","text":"","category":"section"},{"location":"manual/lavd/#Generate-a-Sequence-of-Velocity-and-Vorticity-Fields","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Generate a Sequence of Velocity and Vorticity Fields","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"This step obtains the computed velocity and vorticity fields at a sequence of times, and stores them as a sequence of interpolatable fields. This will greatly speed up how we compute the flow properties (i.e. vorticity) along trajectories.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"t_start = 0.0\nt_end = 8.5\ndt = timestep(u0,sys)\ntr = t_start:dt:t_end\n\nvelxy = velocity_xy(sol,sys,tr) # Vector of interpolatable velocities\nvelseq = VectorFieldSequence(tr,velxy); # Bundle together with the time array\nvortxy = vorticity_xy(sol,sys,tr)\nvortseq = ScalarFieldSequence(tr,vortxy);\nnothing #hide","category":"page"},{"location":"manual/lavd/#Generate-Initial-Conditions","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Generate Initial Conditions","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Here, we generate a grid of initial locations from which to integrate trajectories.","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"X_MIN = -0.5\nX_MAX = 5.5\nY_MIN = -2.0\nY_MAX = 1.0\ndx = 0.04\nlavdgrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx)\nftlegrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx)\nlavd_cache = SurfaceScalarCache(lavdgrid)\nftle_cache = SurfaceScalarCache(ftlegrid)\nx0, y0 = x_grid(lavd_cache), y_grid(lavd_cache)","category":"page"},{"location":"manual/lavd/#Solve-the-IVP-and-Generate-LAVD-Fields","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Solve the IVP and Generate LAVD Fields","text":"","category":"section"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Compute trajectories","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"T = -2.0\nt0 = 8.5\nt1 = t0 + T\n\n@time traj = compute_trajectory(velseq, (x0, y0), (t0, t1));\nnothing #hide","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Compute LAVD","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"LAVD = similar(x0)\ncompute_LAVD!(LAVD, traj, X_MIN, Y_MIN, X_MAX, Y_MAX, vortseq)\nplot(LAVD, lavd_cache, colorbar = true, levels = 20)\nplot!(surfaces(sol,sys,t0))\n#savefig(\"lavd\")","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Compute IVD","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"IVD = similar(x0)\ncompute_IVD!(IVD, traj, X_MIN, Y_MIN, X_MAX, Y_MAX, vortseq)\nplot(IVD, lavd_cache, colorbar = true, levels = 20)\nplot!(surfaces(sol,sys,t0))\n#savefig(\"ivd\")","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Plot the vorticity fields","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"plot(vorticity(sol, sys, t0), sys, layers = false,clim = (-5,5),levels = range(-5,5,length=30), colorbar = true, xlim = (-0.5, 5.5))\nplot!(surfaces(sol,sys,t0))\n#savefig(\"vorticity\")","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"Compute and plot the backward FTLE field","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"T = 8.5\nt0 = 8.5\nxb, yb = displacement_field(velseq,x0,y0,(t0,t0-T),alg=ILMPostProcessing.Euler())\nfFTLE = similar(x0)\ncompute_FTLE!(fFTLE,xb,yb,dx,dx,T);\n\nplot(fFTLE,ftle_cache, colorbar = true, levels = 100)\nplot!(surfaces(sol,sys,t0))\n#savefig(\"ftle\")","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"","category":"page"},{"location":"manual/lavd/","page":"Lagrangian-averaged vorticity deviation (LAVD)","title":"Lagrangian-averaged vorticity deviation (LAVD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/pod/#Proper-orthogonal-decomposition-(POD)","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this example, we will demonstrate the use of proper orthogonal decomposition (POD) for decomposing a flow field into basis modes.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ILMPostProcessing\nusing Plots","category":"page"},{"location":"manual/pod/#Get-the-flow-field-data","page":"Proper orthogonal decomposition (POD)","title":"Get the flow field data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"First, we need some flow field data to analyze. For this purpose, we will use ViscousFlow.jl to get snapshots of the flow for a flat plate at 30 degrees angle of attack at Reynolds number 100.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ViscousFlow\n\nmy_params = Dict()\nmy_params[\"Re\"] = 100\nmy_params[\"freestream speed\"] = 1.0 # in x-dir\nmy_params[\"freestream angle\"] = 0.0 # relative to horizontal\n\nxlim = (-1.0, 5.0)\nylim = (-2.0, 2.0)\nmy_params[\"grid Re\"] = 4.0\n\ng = setup_grid(xlim, ylim, my_params)\n\nΔs = surface_point_spacing(g, my_params)\nbody = Plate(1.0, Δs)\n\ncent = [0.5,0.0]\nα = -30π/180\nX = MotionTransform(cent, α)\njoint = Joint(X)\n\nm = RigidBodyMotion(joint, body)\nx = init_motion_state(body, m)\nupdate_body!(body, x, m)\nsys = viscousflow_system(g, body, phys_params = my_params, motions = m);\n\nu0 = init_sol(sys)\ntspan = (0.0, 20.0)\nintegrator = init(u0, tspan, sys)\n\n# Solve to 10 convective time units\nstep!(integrator, 10)","category":"page"},{"location":"manual/pod/#Assemble-snapshots-of-the-velocity-field-from-the-solution-data","page":"Proper orthogonal decomposition (POD)","title":"Assemble snapshots of the velocity field from the solution data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Here, we make use of the capability of the velocity function to generate an array of velocity fields at a range of times. We will save every 5th time step in this array.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"sol = integrator.sol\ntpod = sol.t[2:5:end]\nX = velocity(sol, sys, tpod);\nnothing #hide","category":"page"},{"location":"manual/pod/#Perform-the-POD","page":"Proper orthogonal decomposition (POD)","title":"Perform the POD","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The POD is simply performed with the PODModes function. This provides a structure containing the modes (phi), the expansion coefficients (a), and the modal energies (lambda). By default, PODModes retains 99% of the energy. This can be changed with the optional argument tolerance.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes = pod(X);\nnothing #hide","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The a array is of size N_t times r, where N_t is the number of time values, and r is the number of modes. The modes are ordered from highest energy to lowest energy.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.a","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this case, 7 modes were retained, at 51 times.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"If we wanted to re-assemble the modes and coefficients to recover the flow at some time instant, we could use the mapreduce function, e.g.,","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"vel_assemble = mapreduce((aj, phi_j) -> aj .* phi_j, +, modes.a[end,:], modes.phi) + modes.Xmean","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this last line, modes.a[end,:] obtains the expansion coefficients at the last time available.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Let's print the first mode, and the corresponding history of the modal coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[1].u,sys,title=\"u\"),\n   plot(modes.phi[1].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,1],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_1(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[1]","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Now let's print the rth mode, and the history of the coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[end].u,sys,title=\"u\"),\n   plot(modes.phi[end].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,end],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_r(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[end]","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/ftle_continuous/#Finite-Time-Lyapunov-Exponent-(FTLE)-with-Continuous-Velocity-Field","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"We present two examples where the FTLE is calculated from known continuous velocity fields as opposed to discrete fields specified at grid points. The first example demonstrates a simple FTLE analysis and lays the conceptual foundation for later analysis on discrete data. The second example showcases an issue of sliding-window FTLE analysis.","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"using ILMPostProcessing\nusing ImmersedLayers\nusing Plots","category":"page"},{"location":"manual/ftle_continuous/#Example-1:-Unsteady-Double-Gyre","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Example 1: Unsteady Double Gyre","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"This example replicates the time-dependent double gyre from Shadden 2005. The double gyre velocity field's specification can be found at https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/examples.html#Sec7.1. The results in this simulation is highly similar.","category":"page"},{"location":"manual/ftle_continuous/#Generate-Initial-Conditions-for-the-IVP","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Generate Initial Conditions for the IVP","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"X_MIN, X_MAX = 0.0, 2.0\nY_MIN, Y_MAX = 0.0, 1.0\ndx = 0.002\n\nftlegrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx);\nftle_cache = SurfaceScalarCache(ftlegrid)\nx0, y0 = x_grid(ftle_cache), y_grid(ftle_cache)","category":"page"},{"location":"manual/ftle_continuous/#Define-the-Double-Gyre's-Vector-Field","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Define the Double Gyre's Vector Field","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"A = 0.1\nepsilon = 0.25\nomega = 2 * π / 10\n\na(s) = epsilon * sin(omega * s)\nb(s) = 1 - 2 * epsilon * sin(omega * s)\nf(x, t) = a(t) * x^2 + b(t) * x\ndfdx(x, t) = 2 * a(t) * x + b(t)\n\nu(x,y,t) = -π * A * sin.(π * f(x, t)) .* cos.(π * y)\nv(x,y,t) = π * A * cos.(π * f(x, t)) .* sin.(π * y) .* dfdx(x, t)","category":"page"},{"location":"manual/ftle_continuous/#Solve-the-Forward-and-Backward-IVPs","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Solve the Forward and Backward IVPs","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"t0 = 0.0\nT = 12\nxf, yf = displacement_field(u,v,x0,y0,(t0,t0+T))\nxb, yb = displacement_field(u,v,x0,y0,(t0,t0-T))","category":"page"},{"location":"manual/ftle_continuous/#Compute-the-Forward-and-Backward-FTLEs","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Compute the Forward and Backward FTLEs","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"fFTLE = similar(x0)\nbFTLE = similar(x0)\ncompute_FTLE!(fFTLE,xf,yf,dx,dx,T)\ncompute_FTLE!(bFTLE,xb,yb,dx,dx,T)","category":"page"},{"location":"manual/ftle_continuous/#Plot-the-FTLEs-on-Top-of-Each-Other","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Plot the FTLEs on Top of Each Other","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"plot(fFTLE, ftle_cache,fill=false, title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\", colorbar=false, levels = 30, c=:inferno)\nplot!(bFTLE, ftle_cache, fill=false, colorbar=false, levels = 30, c=:viridis)","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"The code here creates a gif","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"fFTLE = similar(x0)\nbFTLE = similar(x0)\n\n@gif for t0 in 0.0:1.0:10.0\n    print(t0)\n\n    xf, yf = displacement_field(u,v,x0,y0,(t0,t0+T))\n    xb, yb = displacement_field(u,v,x0,y0,(t0,t0-T))\n\n    compute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n    compute_FTLE!(bFTLE,xb,yb,dx,dx,T)\n\n    plot(fFTLE, ftle_cache,fill=false, title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\", colorbar=false, levels = 30, c=:inferno)\n    plot!(bFTLE, ftle_cache, fill=false, colorbar=false, levels = 30, c=:viridis)\n\nend every 1 fps = 2","category":"page"},{"location":"manual/ftle_continuous/#Example-2-Issues-with-the-Sliding-Window-Approach","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Example 2 - Issues with the Sliding-Window Approach","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"The sliding-window approach attempts to detect Langragian coherent structures (LCS) by computing the FTLE fields over windows of the form [t0, t0 + T] with varying t0 values. However, this approach does not obey Lagrangian invariance because the LCS's at different t0 values do not evolve into each other (Haller 2015).","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"This example illustrates the point above.","category":"page"},{"location":"manual/ftle_continuous/#First,-generate-initial-conditions.","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"First, generate initial conditions.","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"X_MIN, X_MAX = -6.0, 50.0\nY_MIN, Y_MAX = -2, 2\ndx = 0.08\n\nftlegrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx);\nftle_cache = SurfaceScalarCache(ftlegrid)\nx0, y0 = x_grid(ftle_cache), y_grid(ftle_cache)","category":"page"},{"location":"manual/ftle_continuous/#Define-the-Vector-Field","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Define the Vector Field","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"u2(x,y) = 1 + tanh.(x).^2\nv2(x,y) = -2 * tanh.(x) ./ cosh.(x).^2 .* y","category":"page"},{"location":"manual/ftle_continuous/#Solve-the-IVP-and-Compute-FTLEs-with-the-Sliding-Window-Approach","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Solve the IVP and Compute FTLEs with the Sliding-Window Approach","text":"","category":"section"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"As shown in the figure,although the flow is unsteady, the actual LCS is a material line that moves with the flow to the right. Nevertheless, as shown in the gif below, when t0 varies from 0.0 to 10.0, the forward FTLE fields reveals a repelling LCS fixed on the y-axis.","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"(Image: Lack of Lagrangian Invariance)","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"fFTLE = similar(x0)\nT = 5\n\n@gif for t0 in 0.0:0.5:10.0\n    print(t0)\n\n    xf, yf = displacement_field(u2,v2,x0,y0,(t0,t0+T))\n    compute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n\n    plot(fFTLE, ftle_cache,fill=false, title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\", colorbar=false, levels = 30, c=:inferno)\n\nend every 1 fps = 2","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"","category":"page"},{"location":"manual/ftle_continuous/","page":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","title":"Finite-Time Lyapunov Exponent (FTLE) with Continuous Velocity Field","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ILMPostProcessing.jl","page":"Home","title":"ILMPostProcessing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for post-processing solutions of immersed layer PDEs","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to supply a variety of post-processing tools for solutions of PDEs carried out with the ImmersedLayers.jl package, and the domain-specific subpackages, such as ViscousFlow.jl. The post-processing tools[1] currently available are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proper orthogonal decomposition (POD)\nDynamic mode decomposition (DMD)\nFinite-time Lyapunov exponent (FTLE)\nLagrangian-averaged vorticity deviation (LAVD)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.7 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Taira, K. et al (2017) \"Modal Analysis of Fluid Flows: An Overview,\" AIAA Journal, 55(12), 4013–4041.","category":"page"},{"location":"manual/dmdtest/#Dynamic-mode-decomposition-(DMD)","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"In this example, we will demonstrate the use of the de-biased form of dynamic mode decomposition (DMD) for decomposing a simple linear dynamical system.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This example is inspired from example 1 of","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"M.S. Hemati, C.W. Rowley, E.A. Deem, and L.N. Cattafesta    ``De-biasing the dynamic mode decomposition for      applied Koopman spectral analysis of noisy datasets,''      Theoretical and Computational Fluid Dynamics (2017).","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"which introduces the de-biased form of DMD.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The example considers a low-rank linear system with two undamped modes and one dampled mode. The snapshots taken from the solution of the linear system are noised up with zero-mean Gaussian noise.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"using ILMPostProcessing\n\nusing LinearAlgebra\nusing Random\nusing OrdinaryDiffEq\nusing Plots\n\nm = 100 # number of snapshots\nn = 250 # number of states\nr = 6 # rank of DMD\ndt = 0.01 # snapshot time step\nmeas_cov = 0.05 # measurement noise covariance\ninit_cov = 0.1; # initial condition covariance\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Specify characteristic frequencies and growth/decay rates associated with continuous-time dynamics. The DMD rank should be set equal to twice the number of modes (since each mode consists of conjugate pairs)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"f = [1.0, 2.5, 5.5]\ng = [0, 0, -0.3];\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Create the right hand side matrix for the continuous linear system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"k = 2*length(f)\nA = zeros(k,k)\nfor ii in 1:length(f)\n    i1, i2 = 2*ii-1, 2*ii\n    Ai = view(A,i1:i2,i1:i2)\n    Ai .= [g[ii] 2π*f[ii]; -2π*f[ii] g[ii]]\nend","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The true eigenvalues of the system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"true_evals = exp.(eigvals(A)*dt)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Right-hand side of linear system of equations","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dynsys(x,p,t) = A*x","category":"page"},{"location":"manual/dmdtest/#Solve-the-linear-system","page":"Dynamic mode decomposition (DMD)","title":"Solve the linear system","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Set up a random initial condition with elements drawn from N(1,init_cov) and solve the problem.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"x0 = 1 .+ randn(k)*sqrt(init_cov)\n\ntspan = (0,dt*m)\nprob = ODEProblem(dynsys,x0,tspan)\nsol = solve(prob,Tsit5(),saveat=dt);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"For DMD, use the solution snapshots, but randomly rotate them and apply noise to each. (Here, by performing a QR decomposition of a matrix with random entries, Q is a random unitary matrix)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Q, _ = qr(randn(n,k))\ngetsnaps(x) = Q*x .+ sqrt(meas_cov)*randn(n)\nsnaps = map(x -> getsnaps(x),sol.u);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Now perform DMD","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dmdmodes = dmd(snaps,r)\n\nscatter(real(true_evals),imag(true_evals),ratio=1,xlim = (0.7,1.1),ylim=(0,0.4), xlabel=\"\\$Re(\\\\mu)\\$\", ylabel=\"\\$Im(\\\\mu)\\$\",label=\"True\")\nscatter!(real(dmdmodes.evals),imag(dmdmodes.evals),label=\"DMD\")\nθ = range(0,2π,length=100);\nplot!(cos.(θ),sin.(θ),label=\"\")","category":"page"},{"location":"manual/dmdtest/#Compare-the-true-and-DMD-computed-eigenvalues","page":"Dynamic mode decomposition (DMD)","title":"Compare the true and DMD-computed eigenvalues","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Note that these may not be ordered the same, so we have to also determine how to permute the order of them to compare corresponding eigenvalues. We then compute the l2 error","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"vals, idex = findmin(abs2.(true_evals .- transpose(dmdmodes.evals)),dims=2)\nerr = sqrt(sum(vals))","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/ftle/#Finite-Time-Lyapunov-Exponent-(FTLE)","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"In this example, we will compute the finite-time Laypunov exponent (FTLE) field for a co-rotating vortex pair.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"using ILMPostProcessing\nusing ViscousFlow\nusing Plots","category":"page"},{"location":"manual/ftle/#Setup-the-Co-rotating-Vortices-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Setup the Co-rotating Vortices Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The grid Re number is chosen at 10.0 to speed up computations.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"my_params = Dict()\nmy_params[\"Re\"] = 300\nxlim = (-3.0,3.0)\nylim = (-3.0,3.0)\nmy_params[\"grid Re\"] = 10.0\n\ng = setup_grid(xlim,ylim,my_params)\n\nsys = viscousflow_system(g,phys_params=my_params)\n\nσ = 0.1\nx01, y01 = 1.0, 0.0\nx02, y02 = -1.0, 0.0\nA = 3\ntwogauss = SpatialGaussian(σ,σ,x01,y01,A) + SpatialGaussian(σ,σ,x02,y02,A)\n\nu0 = init_sol(twogauss,sys)\n\nplot(vorticity(u0,sys,0.0),sys)","category":"page"},{"location":"manual/ftle/#Solve-the-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Step the integrator repeatedly until the solution is generated for t = (0.0, 18.0).","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"T = 19.0\ntspan = (0.0,T)\nintegrator = init(u0,tspan,sys)\n\n@time begin\n    step!(integrator,T)\nend\n\nsol = integrator.sol\n\nplt = plot(layout = (4,5), size = (800, 800), legend=:false)\ntsnap = 0.0:1.0:T\nfor (i, t) in enumerate(tsnap)\n    plot!(plt[i],vorticity(sol,sys,t),sys,levels=range(0.1,5,length=31))\nend\nplt","category":"page"},{"location":"manual/ftle/#Generate-a-Sequence-of-Velocity-Fields","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Generate a Sequence of Velocity Fields","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This step obtains the computed velocity field at a sequence of times, and stores them as a sequence of interpolatable fields in velseq. This will greatly speed up the steps in which we compute the flow deformation fields.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"t_start = 0.0\nt_end = 19.0\ndt = timestep(u0,sys)\ntr = t_start:dt:t_end\n\nvelxy = velocity_xy(sol,sys,tr) # Vector of interpolatable velocities\nvelseq = VectorFieldSequence(tr,velxy); # Bundle together with the time array\nnothing #hide","category":"page"},{"location":"manual/ftle/#Generate-Initial-Conditions","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Generate Initial Conditions","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Here, we generate a grid of initial locations from which to integrate trajectories.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"X_MIN = -2.0\nX_MAX = 2.0\nY_MIN = -2.0\nY_MAX = 2.0\ndx = 0.01\nftlegrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx)\nftle_cache = SurfaceScalarCache(ftlegrid)\nx0, y0 = x_grid(ftle_cache), y_grid(ftle_cache)","category":"page"},{"location":"manual/ftle/#Solve-the-IVP-and-Generate-FTLE-Fields","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the IVP and Generate FTLE Fields","text":"","category":"section"},{"location":"manual/ftle/#Computing-the-FTLE-Field-at-One-Time-Snapshot","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Field at One Time Snapshot","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"To compute the particle displacement field, we choose an integration time T. We also choose a time t0 at which we desire to see the FTLE field. Note that we will compute both a forward and backward time FTLE field at t0, so we need to ensure we have velocity data available from t0 - T to t0 + T.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"For integration purposes we use the forward Euler method, but any time marching method can be used, e.g., ILMPostProcessing.RK4(), etc.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"T = 6.0\nt0 = 6.0","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The forward displacement field and FTLE field","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xf, yf = displacement_field(velseq,x0,y0,(t0,t0+T),alg=ILMPostProcessing.Euler())\n\nfFTLE = similar(x0)\ncompute_FTLE!(fFTLE,xf,yf,dx,dx,T);\nnothing #hide","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"and now the backward displacement field and FTLE field. We don't actually need to specify the alg because Euler() is the default.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xb, yb = displacement_field(velseq,x0,y0,(t0,t0-T))\n\nbFTLE = similar(x0)\ncompute_FTLE!(bFTLE,xb,yb,dx,dx,T);\nnothing #hide","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Plot the fields on top of each other","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\")","category":"page"},{"location":"manual/ftle/#Computing-the-FTLE-Fields-at-a-Range-of-Times","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Fields at a Range of Times","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Let's see some blocks of particles and how they move as the FTLE field evolves. The example places initial points at t = 6 near the unstable manifold (orange). We will compute the FTLE field after 4 time units (t = 10) and see the particles. The initial block of points is roughly colored according to which side of this manifold it is on.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xp_min = -1.0\nxp_max = 0.0\nyp_min = 0.5\nyp_max = 1.5\ndxp = 0.1\np_grid = PhysicalGrid((xp_min,xp_max),(yp_min,yp_max),dxp)\np_cache = SurfaceScalarCache(p_grid);\nxp0, yp0 = x_grid(p_cache), y_grid(p_cache);\n\nplot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\")\nscatter!(vec(xp0[1:5,1:end]),vec(yp0[1:5,1:end]))\nscatter!(vec(xp0[8:end,1:end]),vec(yp0[8:end,1:end]))","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Now we will advance the block of particles to t = 10 and compute the FTLE fields at that instant.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"t0_ftle = 10.0\nxpf, ypf = displacement_field(velseq,xp0,yp0,(t0,t0_ftle))\n\nxf, yf = displacement_field(velseq,x0,y0,(t0_ftle,t0_ftle+T))\ncompute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n\nxb, yb = displacement_field(velseq,x0,y0,(t0_ftle,t0_ftle-T))\ncompute_FTLE!(bFTLE,xb,yb,dx,dx,T);\nnothing #hide","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Now plot the FTLE fields and particles","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0_ftle\", xlabel=\"x\", ylabel=\"y\")\nscatter!(vec(xpf[1:5,1:end]),vec(ypf[1:5,1:end]))\nscatter!(vec(xpf[8:end,1:end]),vec(ypf[8:end,1:end]))","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The code here creates a gif","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"@gif for t0_ftle in 6.5:0.5:12.0\n    print(t0_ftle)\n\n    xpf, ypf = displacement_field(velseq,xp0,yp0,(t0,t0_ftle))\n\n    xf, yf = displacement_field(velseq,x0,y0,(t0_ftle,t0_ftle+T))\n    compute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n    xb, yb = displacement_field(velseq,x0,y0,(t0_ftle,t0_ftle-T))\n    compute_FTLE!(bFTLE,xb,yb,dx,dx,T)\n\n    plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\n    plot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0_ftle\", xlabel=\"x\", ylabel=\"y\")\n    scatter!(vec(xpf[1:5,1:end]),vec(ypf[1:5,1:end]))\n    scatter!(vec(xpf[8:end,1:end]),vec(ypf[8:end,1:end]))\n\nend every 1 fps = 2","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This page was generated using Literate.jl.","category":"page"}]
}
