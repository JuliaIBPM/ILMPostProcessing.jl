var documenterSearchIndex = {"docs":
[{"location":"manual/functions/#Functions-and-types","page":"Functions and types","title":"Functions and types","text":"","category":"section"},{"location":"manual/functions/#Functions","page":"Functions and types","title":"Functions","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [ILMPostProcessing]\nOrder   = [:function]","category":"page"},{"location":"manual/functions/#ILMPostProcessing.adams_bashforth_2_backward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.adams_bashforth_2_backward","text":"adams_bashforth_2_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate backward in time to compute backward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.adams_bashforth_2_forward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.adams_bashforth_2_forward","text":"adams_bashforth_2_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_FTLE!-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE, nx, ny, T, final_positions, dx, dy)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: an empty 2D array (i.e., FTLE = zeros(Float64, ny - 2, nx - 2)), nx - 2 and ny - 2 accounts for the boundary points in the central difference formula\nnx: number of grid points in x \nny: number of grid points in y \nT: length of integration time\nfinal_positions: solutions of the IVP \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_FTLE!-Tuple{Any, Any, Any, Real, Real, Real}","page":"Functions and types","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE::ScalarGridData, final_x::ScalarGridData, final_y::ScalarGridData, dx::Real, dy::Real, T::Real)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: will hold the FTLE field, in ScalarGridData type\nfinal_x: deformed x positions, in ScalarGridData type\nfinal_y: deformed y positions, in ScalarGridData type \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_streakline-Union{Tuple{S}, Tuple{Any, Any, Vector{S}, Any}} where S<:Real","page":"Functions and types","title":"ILMPostProcessing.compute_streakline","text":"compute_streakline(u,v,X₀::Vector,t[;τmin = t-3.0, Δtstreak=0.01,Δttraj=0.001]) -> Vector, Vector\n\nCalculate a streakline at time t for a velocity field u and v, based on an injection point X₀. The end of the streakline is set by τmin, the earliest time at which a particle passed through the injection point. It defaults to 3 time units before the current instant t. The time step size Δt sets the resolution of the streakline (i.e., how often the particles are sampled along the streakline). It returns arrays of the x and y coordinates of the streakline.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_streamline-Tuple{Function, Function, Any, Tuple, Real}","page":"Functions and types","title":"ILMPostProcessing.compute_streamline","text":"compute_streamline(u,v,X₀,srange::Tuple,t::Real,[;Δt=0.01])\n\nCalculate the streamline(s) passing through location(s) X₀, which can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for a rake of streamlines. The arguments u and v are either interpolated velocity field components from a computational solution or are functions. If they are functions, then each of them should be of the form u(x,y,t) and v(x,y,t); srange is a tuple of the initial and final time of integration; t is the current time at which the streamline is depicted; and Δs is the time-like step size, which defaults to 0.001. The output is the solution structure for the OrdinaryDiffEq package (or, for multiple points, a vector of such solution structures).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_trajectory-Union{Tuple{T}, Tuple{Array{Tuple{T, T}, 1}, StepRangeLen, Any, Tuple}} where T<:Interpolations.AbstractInterpolation","page":"Functions and types","title":"ILMPostProcessing.compute_trajectory","text":"compute_trajectory(vr::Vector{Tuple{AbstractInterpolation,AbstractInterpolation}},tr::AbstractVector,X₀,Trange::Tuple[;Δt=step(tr),alg=Euler()])\n\nCalculate the trajectories of particles with initial location(s) X₀. The argument vr is a vector of spatially-interpolated velocity fields, tr is the corresponding time array, X₀ can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for multiple tracer particles. Trange is a tuple of the starting and ending integration times. The optional keyword arguments are Δt, the time step size (which defaults to the step size in tr, but could be an integer multiple larger than 1). The output is the solution structure for the OrdinaryDiffEq package.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.compute_trajectory-Union{Tuple{T}, Tuple{T, T, Any, Tuple}} where T<:Interpolations.AbstractInterpolation","page":"Functions and types","title":"ILMPostProcessing.compute_trajectory","text":"compute_trajectory(u,v,X₀,Trange::Tuple[;Δt=0.01])\n\nCalculate the trajectory of a tracer particle with initial location(s) X₀, which can be specified as either a single vector [x0,y0], a vector of vectors specifying x, y pairs, or a tuple of vectors or arrays specifying x and y positions, respectively, for multiple tracer particles. The arguments u and v are either interpolated velocity field components from a computational solution or are functions. If they are functions, then each of them should be of the form u(x,y,t) and v(x,y,t); Trange is a tuple of the initial and final time of integration (and the final time can be earlier than the initial time if backward trajectories are desired); and Δt is the time step size, which defaults to 0.001. The output is the solution structure for the OrdinaryDiffEq package (or, for multiple particles, a vector of such solution structures).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.ddt-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T, S}","page":"Functions and types","title":"ILMPostProcessing.ddt","text":"ddt(u::AbstractVector,Δt[,mydiff=:backward_diff])\n\nCalculate the time derivative of vector data u, with time step size Δt. The default method is backward differencing, but this can be changed to :forward_diff or :central_diff.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.displacement_field-Union{Tuple{T}, Tuple{Array{Tuple{T, T}, 1}, StepRangeLen, Any, Any, Tuple}} where T<:Interpolations.AbstractInterpolation","page":"Functions and types","title":"ILMPostProcessing.displacement_field","text":"displacement_field(vr::Vector{Tuple{AbstractInterpolation,AbstractInterpolation}},tr::AbstractVector,x0,y0,Trange::Tuple[;Δt=step(tr),alg=Euler()])\n\nCalculate the displacement of particles initally at coordinates x0 and y0 over the range of times Trange = (ti,tf), using the vector of spatially-interpolated velocity fields in vr (with corresponding times tr). The final time in Trange can be earlier than the initial time if backward trajectories are desired. The optional keyword arguments are Δt, the time step size (which defaults to the step size in tr, but could be an integer multiple larger than 1). \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.dmd-Union{Tuple{T}, Tuple{Vector{T}, Integer}} where T","page":"Functions and types","title":"ILMPostProcessing.dmd","text":"dmd(Xfull,r)\n\nCompute the first r DMD modes from the extended snapshot data in Xfull. Both the original and shifted data are drawn from Xfull, that is: X = Xfull[1:m-1] and Xp = Xfull[2:m]\n\nThis returns the DMD modes and DMD eigenvalues in a DMDModes structure, with fields modes and evals.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.euler_backward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.euler_backward","text":"euler_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate backward in time to compute backward FTLE fields. Note: not backward Euler method.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.euler_forward-NTuple{7, Any}","page":"Functions and types","title":"ILMPostProcessing.euler_forward","text":"euler_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.field_along_trajectory-Tuple{Any, Any, Any}","page":"Functions and types","title":"ILMPostProcessing.field_along_trajectory","text":"fieldalongtrajectory(f,traj::Trajectories,p::Integer[,deriv=0])\n\nEvaluate field f (given as grid data) along the trajectory number p in the  trajectories specified by traj. The output is the history of f along this trajectory. If f is a vector field, then the component histories are output as a tuple. If deriv=1, then it computes the time derivative of the field along the trajectory. The default is deriv=0 (no derivative).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.gen_init_conds-NTuple{6, Any}","page":"Functions and types","title":"ILMPostProcessing.gen_init_conds","text":"gen_init_conds(X_MIN, X_MAX, Y_MIN, Y_MAX, nx, ny)\n\nGenerate a list of initial points (x, y).\n\nThese initial conditions represent a collocated grid with nx points in (X_MIN, X_MAX) and ny points in (Y_MIN, Y_MAX). The points are then flattened to a 1D array. The initial conditions could be used to compute FTLE or to visaulize trajectories.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.make_interp_fields!-NTuple{9, Any}","page":"Functions and types","title":"ILMPostProcessing.make_interp_fields!","text":"make_interp_fields!(u, v, t_start, t_end, dt, velocity_fn, sol, sys, grid)\n\nGenerate an array of interpolatable velocity fields u and v using the solution of a ViscousFlow problem. \n\nEach element of u and v is essentially a \"Vectorfield!\" used when solving an ODEProblem. Note: This function could be included in ViscousFlow.jl. \n\nArguments\n\nu: x-velocity fields\nv: y-velocity fields\nt_start: start time of sol\nt_end: end time of sol \ndt: step size between consecutive velocity fields\nvelocity_fn: function to compute velocity from solution, should be ViscousFlow.velocity\nsys: viscous flow system\ngrid: physical grid\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.pod-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Functions and types","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T}[; tolerance=0.99])\n\nCalculate the POD modes and associated time-varying coefficients from an array of snapshot data X. This X plays the role of a snapshot matrix, whose columns are snapshots of the data. However, it is actually to be stored as a type Vector{T} where T<:GridData. It can be generated with a function like velocity(sol,sys,trange), where sol is a ODESolution, sys is an ILMSystem, and trange is an array of times, e.g., trange=range(1,10,length=100). The number of POD modes retained in the decomposition is set by tolerance: this specifies the fraction of the total energy to keep, and defaults to 99 percent. \n\nThe output of PODModes is a structure with the following fields\n\nXmean: temporal mean of the data. type T\nXnorm: original X vector with mean removed. Each element is of type T\nphi: vector of POD modes. Each element is of type T\na: matrix of POD coefficients. Number of columns is same as number of entries in phi. Column k constitutes the time-varying coefficient for mode k in phi.\nlambda: vector of modal energies, arranged in decreasing order, corresponding to the modes in phi\npsi: matrix of \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#ILMPostProcessing.pod-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T","page":"Functions and types","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T},r::Int)\n\nPerform POD on snapshot data X and truncate to r modes\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#Types","page":"Functions and types","title":"Types","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [ILMPostProcessing]\nOrder   = [:type]","category":"page"},{"location":"manual/functions/#ILMPostProcessing.Trajectories","page":"Functions and types","title":"ILMPostProcessing.Trajectories","text":"Trajectories\n\nType returned by trajectory calculations, containing a set of one or more trajectories. For an instance traj of this type, the trajectory time array can be returned with traj.t. The number of trajectories is returned by traj.np. Any trajectory contained in the set can be obtained with traj[p], where p must be 0 < p <= traj.np. \n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#Index","page":"Functions and types","title":"Index","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"EditURL = \"../../../test/literate/pod.jl\"","category":"page"},{"location":"manual/pod/#Proper-orthogonal-decomposition-(POD)","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this example, we will demonstrate the use of proper orthogonal decomposition (POD) for decomposing a flow field into basis modes.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ILMPostProcessing\nusing Plots","category":"page"},{"location":"manual/pod/#Get-the-flow-field-data","page":"Proper orthogonal decomposition (POD)","title":"Get the flow field data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"First, we need some flow field data to analyze. For this purpose, we will use ViscousFlow.jl to get snapshots of the flow for a flat plate at 30 degrees angle of attack at Reynolds number 100.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ViscousFlow\n\nmy_params = Dict()\nmy_params[\"Re\"] = 100\nmy_params[\"freestream speed\"] = 1.0 # in x-dir\nmy_params[\"freestream angle\"] = 0.0 # relative to horizontal\n\nxlim = (-1.0, 5.0)\nylim = (-2.0, 2.0)\nmy_params[\"grid Re\"] = 4.0\n\ng = setup_grid(xlim, ylim, my_params)\n\nΔs = surface_point_spacing(g, my_params)\nbody = Plate(1.0, Δs)\n\ncent = [0.5,0.0]\nα = -30π/180\nX = MotionTransform(cent, α)\njoint = Joint(X)\n\nm = RigidBodyMotion(joint, body)\nx = init_motion_state(body, m)\nupdate_body!(body, x, m)\nsys = viscousflow_system(g, body, phys_params = my_params, motions = m);\n\nu0 = init_sol(sys)\ntspan = (0.0, 20.0)\nintegrator = init(u0, tspan, sys)\n\n# Solve to 10 convective time units\nstep!(integrator, 10)","category":"page"},{"location":"manual/pod/#Assemble-snapshots-of-the-velocity-field-from-the-solution-data","page":"Proper orthogonal decomposition (POD)","title":"Assemble snapshots of the velocity field from the solution data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Here, we make use of the capability of the velocity function to generate an array of velocity fields at a range of times. We will save every 5th time step in this array.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"sol = integrator.sol\ntpod = sol.t[2:5:end]\nX = velocity(sol, sys, tpod);\nnothing #hide","category":"page"},{"location":"manual/pod/#Perform-the-POD","page":"Proper orthogonal decomposition (POD)","title":"Perform the POD","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The POD is simply performed with the PODModes function. This provides a structure containing the modes (phi), the expansion coefficients (a), and the modal energies (lambda). By default, PODModes retains 99% of the energy. This can be changed with the optional argument tolerance.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes = pod(X);\nnothing #hide","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The a array is of size N_t times r, where N_t is the number of time values, and r is the number of modes. The modes are ordered from highest energy to lowest energy.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.a","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this case, 7 modes were retained, at 51 times.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"If we wanted to re-assemble the modes and coefficients to recover the flow at some time instant, we could use the mapreduce function, e.g.,","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"vel_assemble = mapreduce((aj, phi_j) -> aj .* phi_j, +, modes.a[end,:], modes.phi) + modes.Xmean","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this last line, modes.a[end,:] obtains the expansion coefficients at the last time available.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Let's print the first mode, and the corresponding history of the modal coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[1].u,sys,title=\"u\"),\n   plot(modes.phi[1].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,1],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_1(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[1]","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Now let's print the rth mode, and the history of the coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[end].u,sys,title=\"u\"),\n   plot(modes.phi[end].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,end],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_r(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[end]","category":"page"},{"location":"manual/pod/#POD-functions","page":"Proper orthogonal decomposition (POD)","title":"POD functions","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"pod","category":"page"},{"location":"manual/pod/#ILMPostProcessing.pod","page":"Proper orthogonal decomposition (POD)","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T}[; tolerance=0.99])\n\nCalculate the POD modes and associated time-varying coefficients from an array of snapshot data X. This X plays the role of a snapshot matrix, whose columns are snapshots of the data. However, it is actually to be stored as a type Vector{T} where T<:GridData. It can be generated with a function like velocity(sol,sys,trange), where sol is a ODESolution, sys is an ILMSystem, and trange is an array of times, e.g., trange=range(1,10,length=100). The number of POD modes retained in the decomposition is set by tolerance: this specifies the fraction of the total energy to keep, and defaults to 99 percent. \n\nThe output of PODModes is a structure with the following fields\n\nXmean: temporal mean of the data. type T\nXnorm: original X vector with mean removed. Each element is of type T\nphi: vector of POD modes. Each element is of type T\na: matrix of POD coefficients. Number of columns is same as number of entries in phi. Column k constitutes the time-varying coefficient for mode k in phi.\nlambda: vector of modal energies, arranged in decreasing order, corresponding to the modes in phi\npsi: matrix of \n\n\n\n\n\npod(X::Vector{T},r::Int)\n\nPerform POD on snapshot data X and truncate to r modes\n\n\n\n\n\n","category":"function"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ILMPostProcessing.jl","page":"Home","title":"ILMPostProcessing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for post-processing solutions of immersed layer PDEs","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to supply a variety of post-processing tools for solutions of PDEs carried out with the ImmersedLayers.jl package, and the domain-specific subpackages, such as ViscousFlow.jl. The post-processing tools[1] currently available are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proper orthogonal decomposition (POD)\nDynamic mode decomposition (DMD)\nFinite-time Lyapunov exponent (FTLE)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.7 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Taira, K. et al (2017) \"Modal Analysis of Fluid Flows: An Overview,\" AIAA Journal, 55(12), 4013–4041.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"EditURL = \"../../../test/literate/dmdtest.jl\"","category":"page"},{"location":"manual/dmdtest/#Dynamic-mode-decomposition-(DMD)","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"In this example, we will demonstrate the use of the de-biased form of dynamic mode decomposition (DMD) for decomposing a simple linear dynamical system.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This example is inspired from example 1 of","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"M.S. Hemati, C.W. Rowley, E.A. Deem, and L.N. Cattafesta    ``De-biasing the dynamic mode decomposition for      applied Koopman spectral analysis of noisy datasets,''      Theoretical and Computational Fluid Dynamics (2017).","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"which introduces the de-biased form of DMD.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The example considers a low-rank linear system with two undamped modes and one dampled mode. The snapshots taken from the solution of the linear system are noised up with zero-mean Gaussian noise.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"using ILMPostProcessing\n\nusing LinearAlgebra\nusing Random\nusing OrdinaryDiffEq\nusing Plots\n\nm = 100 # number of snapshots\nn = 250 # number of states\nr = 6 # rank of DMD\ndt = 0.01 # snapshot time step\nmeas_cov = 0.05 # measurement noise covariance\ninit_cov = 0.1; # initial condition covariance\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Specify characteristic frequencies and growth/decay rates associated with continuous-time dynamics. The DMD rank should be set equal to twice the number of modes (since each mode consists of conjugate pairs)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"f = [1.0, 2.5, 5.5]\ng = [0, 0, -0.3];\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Create the right hand side matrix for the continuous linear system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"k = 2*length(f)\nA = zeros(k,k)\nfor ii in 1:length(f)\n    i1, i2 = 2*ii-1, 2*ii\n    Ai = view(A,i1:i2,i1:i2)\n    Ai .= [g[ii] 2π*f[ii]; -2π*f[ii] g[ii]]\nend","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The true eigenvalues of the system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"true_evals = exp.(eigvals(A)*dt)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Right-hand side of linear system of equations","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dynsys(x,p,t) = A*x","category":"page"},{"location":"manual/dmdtest/#Solve-the-linear-system","page":"Dynamic mode decomposition (DMD)","title":"Solve the linear system","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Set up a random initial condition with elements drawn from N(1,init_cov) and solve the problem.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"x0 = 1 .+ randn(k)*sqrt(init_cov)\n\ntspan = (0,dt*m)\nprob = ODEProblem(dynsys,x0,tspan)\nsol = solve(prob,Tsit5(),saveat=dt);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"For DMD, use the solution snapshots, but randomly rotate them and apply noise to each. (Here, by performing a QR decomposition of a matrix with random entries, Q is a random unitary matrix)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Q, _ = qr(randn(n,k))\ngetsnaps(x) = Q*x .+ sqrt(meas_cov)*randn(n)\nsnaps = map(x -> getsnaps(x),sol.u);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Now perform DMD","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dmdmodes = dmd(snaps,r)\n\nscatter(real(true_evals),imag(true_evals),ratio=1,xlim = (0.7,1.1),ylim=(0,0.4), xlabel=\"\\$Re(\\\\mu)\\$\", ylabel=\"\\$Im(\\\\mu)\\$\",label=\"True\")\nscatter!(real(dmdmodes.evals),imag(dmdmodes.evals),label=\"DMD\")\nθ = range(0,2π,length=100);\nplot!(cos.(θ),sin.(θ),label=\"\")","category":"page"},{"location":"manual/dmdtest/#Compare-the-true-and-DMD-computed-eigenvalues","page":"Dynamic mode decomposition (DMD)","title":"Compare the true and DMD-computed eigenvalues","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Note that these may not be ordered the same, so we have to also determine how to permute the order of them to compare corresponding eigenvalues. We then compute the l2 error","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"vals, idex = findmin(abs2.(true_evals .- transpose(dmdmodes.evals)),dims=2)\nerr = sqrt(sum(vals))","category":"page"},{"location":"manual/dmdtest/#DMD-functions","page":"Dynamic mode decomposition (DMD)","title":"DMD functions","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dmd","category":"page"},{"location":"manual/dmdtest/#ILMPostProcessing.dmd","page":"Dynamic mode decomposition (DMD)","title":"ILMPostProcessing.dmd","text":"dmd(Xfull,r)\n\nCompute the first r DMD modes from the extended snapshot data in Xfull. Both the original and shifted data are drawn from Xfull, that is: X = Xfull[1:m-1] and Xp = Xfull[2:m]\n\nThis returns the DMD modes and DMD eigenvalues in a DMDModes structure, with fields modes and evals.\n\n\n\n\n\n","category":"function"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"EditURL = \"../../../test/literate/ftle.jl\"","category":"page"},{"location":"manual/ftle/#Finite-Time-Lyapunov-Exponent-(FTLE)","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"In this example, we will compute the finite-time Laypunov exponent (FTLE) field for a co-rotating vortex pair.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"using ILMPostProcessing\nusing ViscousFlow\nusing Plots","category":"page"},{"location":"manual/ftle/#Setup-the-Co-rotating-Vortices-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Setup the Co-rotating Vortices Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The grid Re number is chosen at 10.0 to speed up computations.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"my_params = Dict()\nmy_params[\"Re\"] = 300\nxlim = (-3.0,3.0)\nylim = (-3.0,3.0)\nmy_params[\"grid Re\"] = 10.0\n\ng = setup_grid(xlim,ylim,my_params)\n\nsys = viscousflow_system(g,phys_params=my_params)\n\nσ = 0.1\nx01, y01 = 1.0, 0.0\nx02, y02 = -1.0, 0.0\nA = 3\ntwogauss = SpatialGaussian(σ,σ,x01,y01,A) + SpatialGaussian(σ,σ,x02,y02,A)\n\nu0 = init_sol(twogauss,sys)\n\nplot(vorticity(u0,sys,0.0),sys)","category":"page"},{"location":"manual/ftle/#Solve-the-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Step the integrator repeatedly until the solution is generated for t = (0.0, 18.0).","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"T = 19.0\ntspan = (0.0,T)\nintegrator = init(u0,tspan,sys)\n\n@time begin\n    step!(integrator,T)\nend\n\nsol = integrator.sol\n\nplt = plot(layout = (4,5), size = (800, 800), legend=:false)\ntsnap = 0.0:1.0:T\nfor (i, t) in enumerate(tsnap)\n    plot!(plt[i],vorticity(sol,sys,t),sys,levels=range(0.1,5,length=31))\nend\nplt","category":"page"},{"location":"manual/ftle/#Discretize-the-Solution-in-Time","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Discretize the Solution in Time","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This step stores the velocity fields as interpolatable fields at chosen time steps so that the velocity fields don't need to be computed every iteration the IVP is solved.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"t_start = 0.0\nt_end = 19.0\ndt = timestep(u0,sys)\ntr = t_start:dt:t_end\n\nvelxy = velocity_xy(sol,sys,tr);\nnothing #hide","category":"page"},{"location":"manual/ftle/#Generate-Initial-Conditions","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Generate Initial Conditions","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Here, we generate a grid of initial locations from which to integrate trajectories.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"X_MIN = -2.0\nX_MAX = 2.0\nY_MIN = -2.0\nY_MAX = 2.0\ndx = 0.01\nftlegrid = PhysicalGrid((X_MIN,X_MAX),(Y_MIN,Y_MAX),dx,optimize=false)\nftle_cache = SurfaceScalarCache(ftlegrid)\nx0, y0 = x_grid(ftle_cache), y_grid(ftle_cache)","category":"page"},{"location":"manual/ftle/#Solve-the-IVP-and-Generate-FTLE-Fields","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the IVP and Generate FTLE Fields","text":"","category":"section"},{"location":"manual/ftle/#Computing-the-FTLE-Field-at-One-Time-Snapshot","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Field at One Time Snapshot","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"To compute the particle displacement field, we choose an integration time T. We also choose a time t0 at which we desire to see the FTLE field. Note that we will compute both a forward and backward time FTLE field at t0, so we need to ensure we have velocity data available from t0 - T to t0 + T.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"For integration purposes we use the forward Euler method, but any time marching method can be used.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"T = 6.0\nt0 = 6.0","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The forward displacement field and FTLE field","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xf, yf = displacement_field(velxy,tr,x0,y0,(t0,t0+T),alg=Euler())\n\nfFTLE = similar(x0)\ncompute_FTLE!(fFTLE,xf,yf,dx,dx,T)","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"and now the backward displacement field and FTLE field. We don't actually need to specify the alg because Euler() is the default.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xb, yb = displacement_field(velxy,tr,x0,y0,(t0,t0-T))\n\nbFTLE = similar(x0)\ncompute_FTLE!(bFTLE,xb,yb,dx,dx,T);\nnothing #hide","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Plot the fields on top of each other","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\")","category":"page"},{"location":"manual/ftle/#Computing-the-FTLE-Fields-at-a-Range-of-Times","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Fields at a Range of Times","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Let's see some blocks of particles and how they move as the FTLE field evolves. The example places initial points at t = 6 near the unstable manifold (orange). We will compute the FTLE field after 4 time units (t = 10) and see the particles. The initial block of points is roughly colored according to which side of this manifold it is on.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"xp_min = -1.0\nxp_max = 0.0\nyp_min = 0.5\nyp_max = 1.5\ndxp = 0.1\np_grid = PhysicalGrid((xp_min,xp_max),(yp_min,yp_max),dxp,optimize=false)\np_cache = SurfaceScalarCache(p_grid);\nxp0, yp0 = x_grid(p_cache), y_grid(p_cache);\n\nplot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\")\nscatter!(vec(xp0[1:5,1:end]),vec(yp0[1:5,1:end]))\nscatter!(vec(xp0[8:end,1:end]),vec(yp0[8:end,1:end]))","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Now we will advance the block of particles to t = 10 and compute the FTLE fields at that instant.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"t0_ftle = 10.0\nxpf, ypf = displacement_field(velxy,tr,xp0,yp0,(t0,t0_ftle))\n\nxf, yf = displacement_field(velxy,tr,x0,y0,(t0_ftle,t0_ftle+T))\ncompute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n\nxb, yb = displacement_field(velxy,tr,x0,y0,(t0_ftle,t0_ftle-T))\ncompute_FTLE!(bFTLE,xb,yb,dx,dx,T);\nnothing #hide","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Now plot the FTLE fields and particles","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\nplot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0_ftle\", xlabel=\"x\", ylabel=\"y\")\nscatter!(vec(xpf[1:5,1:end]),vec(ypf[1:5,1:end]))\nscatter!(vec(xpf[8:end,1:end]),vec(ypf[8:end,1:end]))","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The code here creates a gif","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"@gif for t0_ftle in 6.5:0.5:12.0\n    print(t0_ftle)\n\n    xpf, ypf = displacement_field(velxy,tr,xp0,yp0,(t0,t0_ftle))\n\n    xf, yf = displacement_field(velxy,tr,x0,y0,(t0_ftle,t0_ftle+T))\n    compute_FTLE!(fFTLE,xf,yf,dx,dx,T)\n    xb, yb = displacement_field(velxy,tr,x0,y0,(t0_ftle,t0_ftle-T))\n    compute_FTLE!(bFTLE,xb,yb,dx,dx,T)\n\n    plot(fFTLE,ftle_cache,color=:inferno,size=(800,800))\n    plot!(bFTLE,ftle_cache,color=:viridis,xlim=(-2,2),ylim=(-2,2),title=\"FTLE, t = $t0_ftle\", xlabel=\"x\", ylabel=\"y\")\n    scatter!(vec(xpf[1:5,1:end]),vec(ypf[1:5,1:end]))\n    scatter!(vec(xpf[8:end,1:end]),vec(ypf[8:end,1:end]))\n\nend every 1 fps = 2","category":"page"},{"location":"manual/ftle/#FTLE-functions","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"FTLE functions","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"make_interp_fields!\ngen_init_conds\neuler_forward\neuler_backward\nadams_bashforth_2_forward\nadams_bashforth_2_backward\ncompute_FTLE!","category":"page"},{"location":"manual/ftle/#ILMPostProcessing.make_interp_fields!","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.make_interp_fields!","text":"make_interp_fields!(u, v, t_start, t_end, dt, velocity_fn, sol, sys, grid)\n\nGenerate an array of interpolatable velocity fields u and v using the solution of a ViscousFlow problem. \n\nEach element of u and v is essentially a \"Vectorfield!\" used when solving an ODEProblem. Note: This function could be included in ViscousFlow.jl. \n\nArguments\n\nu: x-velocity fields\nv: y-velocity fields\nt_start: start time of sol\nt_end: end time of sol \ndt: step size between consecutive velocity fields\nvelocity_fn: function to compute velocity from solution, should be ViscousFlow.velocity\nsys: viscous flow system\ngrid: physical grid\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.gen_init_conds","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.gen_init_conds","text":"gen_init_conds(X_MIN, X_MAX, Y_MIN, Y_MAX, nx, ny)\n\nGenerate a list of initial points (x, y).\n\nThese initial conditions represent a collocated grid with nx points in (X_MIN, X_MAX) and ny points in (Y_MIN, Y_MAX). The points are then flattened to a 1D array. The initial conditions could be used to compute FTLE or to visaulize trajectories.\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.euler_forward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.euler_forward","text":"euler_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.euler_backward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.euler_backward","text":"euler_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate backward in time to compute backward FTLE fields. Note: not backward Euler method.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.adams_bashforth_2_forward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.adams_bashforth_2_forward","text":"adams_bashforth_2_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.adams_bashforth_2_backward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.adams_bashforth_2_backward","text":"adams_bashforth_2_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate backward in time to compute backward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.compute_FTLE!","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE, nx, ny, T, final_positions, dx, dy)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: an empty 2D array (i.e., FTLE = zeros(Float64, ny - 2, nx - 2)), nx - 2 and ny - 2 accounts for the boundary points in the central difference formula\nnx: number of grid points in x \nny: number of grid points in y \nT: length of integration time\nfinal_positions: solutions of the IVP \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \n\n\n\n\n\ncompute_FTLE!(FTLE::ScalarGridData, final_x::ScalarGridData, final_y::ScalarGridData, dx::Real, dy::Real, T::Real)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: will hold the FTLE field, in ScalarGridData type\nfinal_x: deformed x positions, in ScalarGridData type\nfinal_y: deformed y positions, in ScalarGridData type \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This page was generated using Literate.jl.","category":"page"}]
}
