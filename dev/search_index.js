var documenterSearchIndex = {"docs":
[{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"EditURL = \"../../../test/literate/pod.jl\"","category":"page"},{"location":"manual/pod/#Proper-orthogonal-decomposition-(POD)","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this example, we will demonstrate the use of proper orthogonal decomposition (POD) for decomposing a flow field into basis modes.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ILMPostProcessing\nusing Plots","category":"page"},{"location":"manual/pod/#Get-the-flow-field-data","page":"Proper orthogonal decomposition (POD)","title":"Get the flow field data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"First, we need some flow field data to analyze. For this purpose, we will use ViscousFlow.jl to get snapshots of the flow for a flat plate at 30 degrees angle of attack at Reynolds number 100.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"using ViscousFlow\n\nmy_params = Dict()\nmy_params[\"Re\"] = 100\nmy_params[\"freestream speed\"] = 1.0 # in x-dir\nmy_params[\"freestream angle\"] = 0.0 # relative to horizontal\n\nxlim = (-1.0, 5.0)\nylim = (-2.0, 2.0)\nmy_params[\"grid Re\"] = 4.0\n\ng = setup_grid(xlim, ylim, my_params)\n\nΔs = surface_point_spacing(g, my_params)\nbody = Plate(1.0, Δs)\n\ncent = [0.5,0.0]\nα = -30π/180\nX = MotionTransform(cent, α)\njoint = Joint(X)\n\nm = RigidBodyMotion(joint, body)\nx = init_motion_state(body, m)\nupdate_body!(body, x, m)\nsys = viscousflow_system(g, body, phys_params = my_params, motions = m);\n\nu0 = init_sol(sys)\ntspan = (0.0, 20.0)\nintegrator = init(u0, tspan, sys)\n\n# Solve to 10 convective time units\nstep!(integrator, 10)","category":"page"},{"location":"manual/pod/#Assemble-snapshots-of-the-velocity-field-from-the-solution-data","page":"Proper orthogonal decomposition (POD)","title":"Assemble snapshots of the velocity field from the solution data","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Here, we make use of the capability of the velocity function to generate an array of velocity fields at a range of times. We will save every 5th time step in this array.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"sol = integrator.sol\ntpod = sol.t[2:5:end]\nX = velocity(sol, sys, tpod);\nnothing #hide","category":"page"},{"location":"manual/pod/#Perform-the-POD","page":"Proper orthogonal decomposition (POD)","title":"Perform the POD","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The POD is simply performed with the PODModes function. This provides a structure containing the modes (phi), the expansion coefficients (a), and the modal energies (lambda). By default, PODModes retains 99% of the energy. This can be changed with the optional argument tolerance.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes = pod(X);\nnothing #hide","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The a array is of size N_t times r, where N_t is the number of time values, and r is the number of modes. The modes are ordered from highest energy to lowest energy.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.a","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this case, 7 modes were retained, at 51 times.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"If we wanted to re-assemble the modes and coefficients to recover the flow at some time instant, we could use the mapreduce function, e.g.,","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"vel_assemble = mapreduce((aj, phi_j) -> aj .* phi_j, +, modes.a[end,:], modes.phi) + modes.Xmean","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"In this last line, modes.a[end,:] obtains the expansion coefficients at the last time available.","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Let's print the first mode, and the corresponding history of the modal coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[1].u,sys,title=\"u\"),\n   plot(modes.phi[1].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,1],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_1(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[1]","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"Now let's print the rth mode, and the history of the coefficient in the decomposition","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"plot(layout=[2;1],plot(modes.phi[end].u,sys,title=\"u\"),\n   plot(modes.phi[end].v,sys,title=\"v\"),\n   plot(tpod,modes.a[:,end],xlim=(0,Inf),xlabel=\"\\$t\\$\",ylabel=\"\\$a_r(t)\\$\"))","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"The energy associated with this mode is","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"modes.lambda[end]","category":"page"},{"location":"manual/pod/#POD-functions","page":"Proper orthogonal decomposition (POD)","title":"POD functions","text":"","category":"section"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"pod","category":"page"},{"location":"manual/pod/#ILMPostProcessing.pod","page":"Proper orthogonal decomposition (POD)","title":"ILMPostProcessing.pod","text":"pod(X::Vector{T}[; tolerance=0.99])\n\nCalculate the POD modes and associated time-varying coefficients from an array of snapshot data X. This X plays the role of a snapshot matrix, whose columns are snapshots of the data. However, it is actually to be stored as a type Vector{T} where T<:GridData. It can be generated with a function like velocity(sol,sys,trange), where sol is a ODESolution, sys is an ILMSystem, and trange is an array of times, e.g., trange=range(1,10,length=100). The number of POD modes retained in the decomposition is set by tolerance: this specifies the fraction of the total energy to keep, and defaults to 99 percent. \n\nThe output of PODModes is a structure with the following fields\n\nXmean: temporal mean of the data. type T\nXnorm: original X vector with mean removed. Each element is of type T\nphi: vector of POD modes. Each element is of type T\na: matrix of POD coefficients. Number of columns is same as number of entries in phi. Column k constitutes the time-varying coefficient for mode k in phi.\nlambda: vector of modal energies, arranged in decreasing order, corresponding to the modes in phi\npsi: matrix of \n\n\n\n\n\npod(X::Vector{T},r::Int)\n\nPerform POD on snapshot data X and truncate to r modes\n\n\n\n\n\n","category":"function"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"","category":"page"},{"location":"manual/pod/","page":"Proper orthogonal decomposition (POD)","title":"Proper orthogonal decomposition (POD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ILMPostProcessing.jl","page":"Home","title":"ILMPostProcessing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for post-processing solutions of immersed layer PDEs","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to supply a variety of post-processing tools for solutions of PDEs carried out with the ImmersedLayers.jl package, and the domain-specific subpackages, such as ViscousFlow.jl. The post-processing tools[1] currently available are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proper orthogonal decomposition (POD)\nDynamic mode decomposition (DMD)\nFinite-time Lyapunov exponent (FTLE)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.7 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ILMPostProcessing","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Taira, K. et al (2017) \"Modal Analysis of Fluid Flows: An Overview,\" AIAA Journal, 55(12), 4013–4041.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"EditURL = \"../../../test/literate/dmdtest.jl\"","category":"page"},{"location":"manual/dmdtest/#Dynamic-mode-decomposition-(DMD)","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"In this example, we will demonstrate the use of dynamic mode decomposition (DMD) for decomposing a simple linear dynamical system.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This example is inspired from example 1 of","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"M.S. Hemati, C.W. Rowley, E.A. Deem, and L.N. Cattafesta    ``De-biasing the dynamic mode decomposition for      applied Koopman spectral analysis of noisy datasets,''      Theoretical and Computational Fluid Dynamics (2017).","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The example considers a low-rank linear system with two undamped modes and one dampled mode. The snapshots taken from the solution of the linear system are noised up with zero-mean Gaussian noise.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"using ILMPostProcessing\n\nusing LinearAlgebra\nusing Random\nusing OrdinaryDiffEq\nusing Plots\n\nm = 100 # number of snapshots\nn = 250 # number of states\nr = 6 # rank of DMD\ndt = 0.01 # snapshot time step\nmeas_cov = 0.05 # measurement noise covariance\ninit_cov = 0.1 # initial condition covariance","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Specify characteristic frequencies and growth/decay rates associated with continuous-time dynamics. The DMD rank should be set equal to twice the number of modes (since each mode consists of conjugate pairs)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"f = [1.0, 2.5, 5.5]\ng = [0, 0, -0.3]","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Create the right hand side matrix for the continuous linear system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"k = 2*length(f)\nA = zeros(k,k)\nfor ii in 1:length(f)\n    i1, i2 = 2*ii-1, 2*ii\n    Ai = view(A,i1:i2,i1:i2)\n    Ai .= [g[ii] 2π*f[ii]; -2π*f[ii] g[ii]]\nend","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"The true eigenvalues of the system","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"true_evals = exp.(eigvals(A)*dt)","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Right-hand side of linear system of equations","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dynsys(x,p,t) = A*x","category":"page"},{"location":"manual/dmdtest/#Solve-the-linear-system","page":"Dynamic mode decomposition (DMD)","title":"Solve the linear system","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Set up a random initial condition with elements drawn from N(1,init_cov) and solve the problem.","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"x0 = 1 .+ randn(k)*sqrt(init_cov)\n\ntspan = (0,dt*m)\nprob = ODEProblem(dynsys,x0,tspan)\nsol = solve(prob,Tsit5(),saveat=dt);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"For DMD, use the solution snapshots, but randomly rotate them and apply noise to each","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Q, _ = qr(randn(n,k))\ngetsnaps(x) = Q*x .+ sqrt(meas_cov)*randn(n)\nsnaps = map(x -> getsnaps(x),sol.u);\nnothing #hide","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Now perform DMD","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dmdmodes = dmd(snaps,r)\n\nscatter(real(true_evals),imag(true_evals),ratio=1,xlim = (0.7,1.1),ylim=(0,0.4))\nscatter!(real(dmdmodes.evals),imag(dmdmodes.evals))\nθ = range(0,2π,length=100);\nplot!(cos.(θ),sin.(θ))","category":"page"},{"location":"manual/dmdtest/#Compare-the-true-and-DMD-computed-eigenvalues","page":"Dynamic mode decomposition (DMD)","title":"Compare the true and DMD-computed eigenvalues","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"Note that these may not be ordered the same, so we have to also determine how to permute the order of them to compare corresponding eigenvalues. We then compute the l2 error","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"vals, idex = findmin(abs2.(true_evals .- transpose(dmdmodes.evals)),dims=2)\nerr = sqrt(sum(vals))","category":"page"},{"location":"manual/dmdtest/#DMD-functions","page":"Dynamic mode decomposition (DMD)","title":"DMD functions","text":"","category":"section"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"dmd","category":"page"},{"location":"manual/dmdtest/#ILMPostProcessing.dmd","page":"Dynamic mode decomposition (DMD)","title":"ILMPostProcessing.dmd","text":"dmd(Xfull,r)\n\nCompute the first r DMD modes from the extended snapshot data in Xfull. Both the original and shifted data are drawn from Xfull, that is: X = Xfull1m-1 and Xp = Xfull2m\n\nThis returns the DMD modes and DMD eigenvalues in a DMDModes structure, with fields modes and evals.\n\n\n\n\n\n","category":"function"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"","category":"page"},{"location":"manual/dmdtest/","page":"Dynamic mode decomposition (DMD)","title":"Dynamic mode decomposition (DMD)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"EditURL = \"../../../test/literate/ftle.jl\"","category":"page"},{"location":"manual/ftle/#Finite-Time-Lyapunov-Exponent-(FTLE)","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"In this example, we will compute the finite-time Laypunov exponent (FTLE) field for a co-rotating vortex pair.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"CurrentModule = ILMPostProcessing","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"using ILMPostProcessing\nusing ViscousFlow\nusing Plots","category":"page"},{"location":"manual/ftle/#Setup-the-Co-rotating-Vortices-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Setup the Co-rotating Vortices Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The grid Re number is chosen at 10.0 to speed up computations.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"my_params = Dict()\nmy_params[\"Re\"] = 300\nxlim = (-3.0,3.0)\nylim = (-3.0,3.0)\nmy_params[\"grid Re\"] = 10.0\n\ng = setup_grid(xlim,ylim,my_params)\n\nsys = viscousflow_system(g,phys_params=my_params)\n\nσ = 0.1\nx01, y01 = 1.0, 0.0\nx02, y02 = -1.0, 0.0\nA = 3\ntwogauss = SpatialGaussian(σ,σ,x01,y01,A) + SpatialGaussian(σ,σ,x02,y02,A)\n\nu0 = init_sol(twogauss,sys)\n\nplot(vorticity(u0,sys,0.0),sys)","category":"page"},{"location":"manual/ftle/#Solve-the-Problem","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the Problem","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Step the integrator repeatedly until the solution is generated for t = (0.0, 18.0).","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"T = 18.0\ntspan = (0.0,T)\nintegrator = init(u0,tspan,sys)\n\n@time begin\n    step!(integrator,T)\nend\n\nsol = integrator.sol\n\nplt = plot(layout = (5,5), size = (800, 800), legend=:false)\ntsnap = 0.0:1.0:T\nfor (i, t) in enumerate(tsnap)\n    plot!(plt[i],vorticity(sol,sys,t),sys,levels=range(0.1,5,length=31))\nend\nsavefig(plt,\"CoRotating.pdf\")\nplt","category":"page"},{"location":"manual/ftle/#Discretize-the-Solution-in-Time","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Discretize the Solution in Time","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This step stores the velocity fields as interpolatable fields at chosen time steps so that the velocity fields don't need to be computed every iteration the IVP is solved.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"u = []\nv = []\nt_start = 0.0\nt_end = 18.0\ndt = 0.01\n\nmake_interp_fields!(u, v, t_start, t_end, dt, ViscousFlow.velocity, sol, sys, g)","category":"page"},{"location":"manual/ftle/#Generate-Initial-Conditions","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Generate Initial Conditions","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"X_MIN = -2.0\nX_MAX = 2.0\nY_MIN = -2.0\nY_MAX = 2.0\nnx, ny = 400, 400\n\ninitial_conditions, dx, dy = gen_init_conds(X_MIN, X_MAX, Y_MIN, Y_MAX, nx, ny)","category":"page"},{"location":"manual/ftle/#Solve-the-IVP-and-Generate-FTLE-Fields","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Solve the IVP and Generate FTLE Fields","text":"","category":"section"},{"location":"manual/ftle/#Computing-the-FTLE-Field-at-One-Time-Snapshot","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Field at One Time Snapshot","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Forward Euler's method is used here, but can also use ILMPostProcessing.adamsbashforth2_forward.","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"FTLE = zeros(Float64, ny - 2, nx - 2)\nT = 6.0\nt0 = 6.0\n\nw = euler_forward(initial_conditions, u, v, t0, t_start, dt, T); # final trajectories from forward integration\nz = euler_backward(initial_conditions, u, v, t0, t_start, dt, T); # final trajectories from backward integration\n\nFTLE_forward = zeros(Float64, ny - 2, nx - 2)\ncompute_FTLE!(FTLE_forward, nx, ny, T, w, dx, dy);\n\nFTLE_backward = zeros(Float64, ny - 2, nx - 2)\ncompute_FTLE!(FTLE_backward, nx, ny, T, z, dx, dy);\n\nx = range(X_MIN + dx, stop = X_MAX - dx, length=nx - 2)\ny = range(Y_MIN + dy, stop = Y_MAX - dy, length=ny - 2)\n\ncontour(x, y, FTLE_forward, fill=false, title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\", colorbar=false, c=:inferno, ratio = 1, xlim = (-2, 2), ylim = (-2, 2), size = (800, 800), label = \"Forward FTLE\", legend=:topright)\ncontour!(x, y, FTLE_backward, fill=false, colorbar=false, c=:viridis)\n\nplot!([], [], label=\"Forward FTLE\", linecolor=:orange)\nplot!([], [], label=\"Backward FTLE\", linecolor=:green)","category":"page"},{"location":"manual/ftle/#Computing-the-FTLE-Fields-at-a-Range-of-Times-and-Generate-GIF","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Computing the FTLE Fields at a Range of Times and Generate GIF","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"Also advances the trajectories of a group of points. The first example places initial points near the unstable manifold (orange).","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"x_min = -1.0\nx_max = 0.0\ny_min = 0.5\ny_max = 1.5\nnx_p, ny_p = 10, 10\n\ninitial_points, dx_p, dy_p = gen_init_conds(x_min, x_max, y_min, y_max, nx_p, ny_p)\n\nFTLE = zeros(Float64, ny - 2, nx - 2)\nT = 6.0","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"The code here creates a gif","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"@gif for t0 in 6.0:0.5:12.0\n    print(t0)\n\n    points = euler_forward(initial_points, u, v, 6.0, t_start, dt, t0 - 6.0)\n\n    w = euler_forward(initial_conditions, u, v, t0, t_start, dt, T); # final trajectories from forward integration\n    z = euler_backward(initial_conditions, u, v, t0, t_start, dt, T); # final trajectories from backward integration\n\n    FTLE_forward = zeros(Float64, ny - 2, nx - 2)\n    compute_FTLE!(FTLE_forward, nx, ny, T, w, dx, dy);\n\n    FTLE_backward = zeros(Float64, ny - 2, nx - 2)\n    compute_FTLE!(FTLE_backward, nx, ny, T, z, dx, dy);\n\n    x = range(X_MIN + dx, stop = X_MAX - dx, length=nx - 2)\n    y = range(Y_MIN + dy, stop = Y_MAX - dy, length=ny - 2)\n\n    contour(x, y, FTLE_forward, fill=false, title=\"FTLE, t = $t0\", xlabel=\"x\", ylabel=\"y\", colorbar=false, c=:inferno, xlim = (-2, 2), ylim = (-2, 2), ratio = 1, size = (800, 800))\n    contour!(x, y, FTLE_backward, fill=false, colorbar=false, c=:viridis)\n\n    plot!([], [], label=\"Forward FTLE\", linecolor=:orange)\n    plot!([], [], label=\"Backward FTLE\", linecolor=:green)\n    scatter!(points[:,1], points[:,2], label = \"Points\", markercolor=:black, legend=:topright)\nend every 1 fps = 2","category":"page"},{"location":"manual/ftle/#FTLE-functions","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"FTLE functions","text":"","category":"section"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"make_interp_fields!\ngen_init_conds\neuler_forward\neuler_backward\nadams_bashforth_2_forward\nadams_bashforth_2_backward\ncompute_FTLE!","category":"page"},{"location":"manual/ftle/#ILMPostProcessing.make_interp_fields!","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.make_interp_fields!","text":"make_interp_fields!(u, v, t_start, t_end, dt, velocity_fn, sol, sys, grid)\n\nGenerate an array of interpolatable velocity fields u and v using the solution of a ViscousFlow problem. \n\nEach element of u and v is essentially a \"Vectorfield!\" used when solving an ODEProblem. Note: This function could be included in ViscousFlow.jl. \n\nArguments\n\nu: x-velocity fields\nv: y-velocity fields\nt_start: start time of sol\nt_end: end time of sol \ndt: step size between consecutive velocity fields\nvelocity_fn: function to compute velocity from solution, should be ViscousFlow.velocity\nsys: viscous flow system\ngrid: physical grid\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.gen_init_conds","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.gen_init_conds","text":"gen_init_conds(X_MIN, X_MAX, Y_MIN, Y_MAX, nx, ny)\n\nGenerate a list of initial points (x, y).\n\nThese initial conditions represent a collocated grid with nx points in (X_MIN, X_MAX) and ny points in (Y_MIN, Y_MAX). The points are then flattened to a 1D array. The initial conditions could be used to compute FTLE or to visaulize trajectories.\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.euler_forward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.euler_forward","text":"euler_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.euler_backward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.euler_backward","text":"euler_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using forward Euler method.\n\nIntegrate backward in time to compute backward FTLE fields. Note: not backward Euler method.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.adams_bashforth_2_forward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.adams_bashforth_2_forward","text":"adams_bashforth_2_forward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate forward in time to compute forward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.adams_bashforth_2_backward","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.adams_bashforth_2_backward","text":"adams_bashforth_2_backward(initial_conditions, u, v, t0, t_start, dt, T)\n\nSolve the initial value problem (IVP) using 2-step Adams-Bashforth method.\n\nIntegrate backward in time to compute backward FTLE fields.\n\nArguments\n\ninitial_conditions: generated with function geninitconds\nu: array of x-velocity fields\nv: array of y-velocity fields\nt0: initial time\nt_start: start time of u and v\ndt: step size between consecutive velocity fields\nT: length of integration time\n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/#ILMPostProcessing.compute_FTLE!","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"ILMPostProcessing.compute_FTLE!","text":"compute_FTLE!(FTLE, nx, ny, T, final_positions, dx, dy)\n\nCompute the FTLE field given the final positions of initial points on a collocated grid. \n\nThe underlying math is detailed in: https://shaddenlab.berkeley.edu/uploads/LCS-tutorial/computation.html. For each grid point, first compute the gradient of the flow map using two point central differencing. Then, calculate the maximum eigenvalue of the 2 x 2 gradient matrix. Finally, compute the FTLE value using the eigenvalue.\n\nArguments\n\nFTLE: an empty 2D array (i.e., FTLE = zeros(Float64, ny - 2, nx - 2)), nx - 2 and ny - 2 accounts for the boundary points in the central difference formula\nnx: number of grid points in x \nny: number of grid points in y \nT: length of integration time\nfinal_positions: solutions of the IVP \ndx: spacing of initial grids in x \ndy: spacing of initial grids in y \n\n\n\n\n\n","category":"function"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"","category":"page"},{"location":"manual/ftle/","page":"Finite-Time Lyapunov Exponent (FTLE)","title":"Finite-Time Lyapunov Exponent (FTLE)","text":"This page was generated using Literate.jl.","category":"page"}]
}
